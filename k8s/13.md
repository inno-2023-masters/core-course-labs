# Kubernetes StatefulSet

## StatefulSut `app-python`
I have introduced `k8s/app_python/statefulset.yaml` instead of `k8s/app_python/deployment.yaml`.

---

Let's check StatefulSet:
* ```shell
  helm secrets install app-python-release app-python -f ./secrets.yaml
  ```
  <u>Output:</u>
  ```text
  NAME: app-python-release
  LAST DEPLOYED: Tue Nov 28 21:56:34 2023
  NAMESPACE: default
  STATUS: deployed
  REVISION: 1
  NOTES:
  1. Get the application URL by running these commands:
     export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=app-python,app.kubernetes.io/instance=app-python-release" -o jsonpath="{.items[0].metadata.name}")
     export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
     echo "Visit http://127.0.0.1:8080 to use your application"
     kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT
     ./secrets.yaml.dec
  ```
* ```shell
  kubectl get po,sts,svc,pvc
  ```
  <u>Output:</u>
  ```text
  NAME                       READY   STATUS    RESTARTS   AGE
  pod/app-python-release-0   1/1     Running   0          101s
  pod/app-python-release-1   1/1     Running   0          90s

  NAME                                  READY   AGE
  statefulset.apps/app-python-release   2/2     101s

  NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
  service/app-python-release   ClusterIP   10.104.10.164   <none>        8080/TCP   101s
  service/kubernetes           ClusterIP   10.96.0.1       <none>        443/TCP    7d23h

  NAME                                                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
  persistentvolumeclaim/visits-app-python-release-0   Bound    pvc-5dcc7221-be50-4c5e-b09e-896540ffc20b   1Mi        RWO            standard       23m
  persistentvolumeclaim/visits-app-python-release-1   Bound    pvc-19a61356-a4c0-4dc5-9a53-25e7179d6c9d   1Mi        RWO            standard       90s
  ```
* ```shell
  minikube service app-python-release
  ```
  <u>Output:</u>
  ```text
  |-----------|--------------------|-------------|--------------|
  | NAMESPACE |        NAME        | TARGET PORT |     URL      |
  |-----------|--------------------|-------------|--------------|
  | default   | app-python-release |             | No node port |
  |-----------|--------------------|-------------|--------------|
  üòø  service default/app-python-release has no node port
  üèÉ  Starting tunnel for service app-python-release.
  |-----------|--------------------|-------------|------------------------|
  | NAMESPACE |        NAME        | TARGET PORT |          URL           |
  |-----------|--------------------|-------------|------------------------|
  | default   | app-python-release |             | http://127.0.0.1:50030 |
  |-----------|--------------------|-------------|------------------------|
  üéâ  Opening service default/app-python-release in default browser...
  ```
* I have accessed the app from different tabs and modes (default & incognitio).
* ```shell
  kubectl exec app-python-release-0 -- cat visits_dir/visits
  ```
  <u>Output:</u>
  ```text
  2
  ```
* ```shell
  kubectl exec app-python-release-1 -- cat visits_dir/visits
  ```
  <u>Output:</u>
  ```text
  14
  ```

The numbers are different because of service load balancer work. Each pod has its own `visits` file, and we can get the total number of application's main page visits by summing them up (`14 + 2 = 16` total visits). As we can see the load balancing is not perfect in this case.

## Ordering Guarantee and Parallel Operations
* Why ordering guarantees are unnecessary for the app?
  
  <u>Answer:</u>
  **StatefulSets**, with their ordering guarantees, are particularly beneficial for applications that require sequential start and stop sequences, as they help maintain the order and data consistency.

   Since this application has no shared data between its instances and each pod has its own filesystem, there is no sense in ordering guarantees.
* How to make StatefulSet controller to launch or terminate all Pods in parallel?

  <u>Answer:</u>
  We can add pod management policy to `statefulset.yaml`
  ```yaml
  spec:
    podManagementPolicy: Parallel
  ```
  
## StatefulSut `app-kotlin`
I have introduced `k8s/app_kotlin/statefulset.yaml` instead of `k8s/app_kotlin/deployment.yaml`.

---


* ```shell
  helm secrets install app-kotlin-release app-kotlin -f ./secrets.yaml
  ```
  <u>Output:</u>
  ```text
  NAME: app-kotlin-release
  LAST DEPLOYED: Wed Nov 29 01:49:08 2023
  NAMESPACE: default
  STATUS: deployed
  REVISION: 1
  NOTES:
  1. Get the application URL by running these commands:
     export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=app-kotlin,app.kubernetes.io/instance=app-kotlin-release" -o jsonpath="{.items[0].metadata.name}")
     export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
     echo "Visit http://127.0.0.1:8080 to use your application"
     kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT
  ```
* ```shell
  kubectl get po,sts,svc,pvc
  ```
  <u>Output:</u>
  ```text
  NAME                                        READY   STATUS    RESTARTS   AGE
  pod/app-kotlin-release-0                    2/2     Running   0          4m22s
  pod/app-kotlin-release-1                    2/2     Running   0          4m21s
  pod/vault-0                                 1/1     Running   0          163m
  pod/vault-agent-injector-5cd8b87c6c-98r7s   1/1     Running   0          163m

  NAME                                  READY   AGE
  statefulset.apps/app-kotlin-release   2/2     4m22s
  statefulset.apps/vault                1/1     163m

  NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
  service/app-kotlin-release         ClusterIP   10.106.201.161   <none>        8080/TCP            4m22s
  service/kubernetes                 ClusterIP   10.96.0.1        <none>        443/TCP             8d
  service/vault                      ClusterIP   10.111.176.177   <none>        8200/TCP,8201/TCP   163m
  service/vault-agent-injector-svc   ClusterIP   10.100.254.217   <none>        443/TCP             163m
  service/vault-internal             ClusterIP   None             <none>        8200/TCP,8201/TCP   163m

  NAME                                                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
  persistentvolumeclaim/data-vault-0                  Bound    pvc-26ef7146-07d1-4265-be8e-98c6d5987215   10Gi       RWO            standard       168m
  persistentvolumeclaim/visits-app-kotlin-release-0   Bound    pvc-e8a3a24e-d674-4e07-b643-0ce7dd391629   1Mi        RWO            standard       162m
  persistentvolumeclaim/visits-app-kotlin-release-1   Bound    pvc-87461b41-3f53-481c-a808-e7694c89772e   1Mi        RWO            standard       154m
  persistentvolumeclaim/visits-app-python-release-0   Bound    pvc-5dcc7221-be50-4c5e-b09e-896540ffc20b   1Mi        RWO            standard       4h18m
  persistentvolumeclaim/visits-app-python-release-1   Bound    pvc-19a61356-a4c0-4dc5-9a53-25e7179d6c9d   1Mi        RWO            standard       3h56m
  ```
* ```shell
  minikube service app-kotlin-release
  ```
  <u>Output:</u>
  ```text
  NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION
  app-kotlin-release      default         1               2023-11-29 01:49:08.608165 +0300 MSK    deployed        app-kotlin-0.1.0        1.16.0     
  vault                   default         1               2023-11-28 23:10:05.411938 +0300 MSK    deployed        vault-0.26.1            1.15.1     
  i.nafikov@macbook-C02FH1KGMD6R k8s % minikube service app-kotlin-release
  |-----------|--------------------|-------------|--------------|
  | NAMESPACE |        NAME        | TARGET PORT |     URL      |
  |-----------|--------------------|-------------|--------------|
  | default   | app-kotlin-release |             | No node port |
  |-----------|--------------------|-------------|--------------|
  üòø  service default/app-kotlin-release has no node port
  üèÉ  Starting tunnel for service app-kotlin-release.
  |-----------|--------------------|-------------|------------------------|
  | NAMESPACE |        NAME        | TARGET PORT |          URL           |
  |-----------|--------------------|-------------|------------------------|
  | default   | app-kotlin-release |             | http://127.0.0.1:61738 |
  |-----------|--------------------|-------------|------------------------|
  üéâ  Opening service default/app-kotlin-release in default browser...
  ‚ùó  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.
  ```
* I have accessed the app from different tabs and modes (default & incognitio).
* ```shell
  kubectl exec app-kotlin-release-0 -c app-kotlin -- cat visits_dir/visits
  ```
  <u>Output:</u>
  ```text
  9
  ```
* ```shell
  kubectl exec app-kotlin-release-1 -c app-kotlin -- cat visits_dir/visits
  ```
  <u>Output:</u>
  ```text
  24
  ```

## Update Strategies

1. **Rolling deployment** ‚Äî the default strategy that allows you to update a set of pods without downtime. It replaces pods running the old version of the application with the new version, one by one.
2. **Recreate deployment** ‚Äî an all-or-nothing method that lets you update an application instantly, with some downtime. It terminates all pods and replaces them with the new version.
3. **Ramped slow rollout** ‚Äî rolls out replicas of the new version, while in parallel, shutting down old replicas.
4. **Best-effort controlled rollout** ‚Äî specifies a ‚Äúmax unavailable‚Äù parameter which indicates what percentage of existing pods can be unavailable during the upgrade, enabling the rollout to happen much more quickly.
5. **Blue/green deployment** ‚Äî a deployment strategy in which you create two separate, but identical environments, and over to the new environment.
6. **Canary deployment** ‚Äî uses a progressive delivery approach, with one version of the application serving most users, and another, newer version serving a small pool of test users. The test deployment is rolled out to more users if it is successful.
7. **Shadow deployment** ‚Äî the new version of the application (the ‚Äúshadow‚Äù version) receives real-world traffic alongside the current version, but without affecting end-users.
8. **A/B testing** ‚Äî rolls out two or more versions of an application feature to a subset of users simultaneously to see which one performs better in terms of user engagement, error rates, or other KPIs.

### References:
[8 Kubernetes Deployment Strategies: Roll Out Like the Pros](https://spot.io/resources/kubernetes-autoscaling/5-kubernetes-deployment-strategies-roll-out-like-the-pros/)